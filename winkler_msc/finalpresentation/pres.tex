
% Template by Arnau, based on:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES
%----------------------------------------------------------------------------------------

\documentclass[5pt]{beamer}
\usefonttheme{serif}
%% serif
%% professionalfonts
%% structurebold
%% structureitalicserif
%% structuresmallcapsserif

\mode<presentation> {

\usetheme{Boadilla}

% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.

% \usecolortheme{albatross}
%\usecolortheme{beaver}
%\usecolortheme{beetle}
%\usecolortheme{crane}
% \usecolortheme{dolphin}
%\usecolortheme{dove}
%\usecolortheme{fly}
%\usecolortheme{lily}
%\usecolortheme{orchid}
%\usecolortheme{rose}
%\usecolortheme{seagull}
\usecolortheme{seahorse}  % The them I usually use, because it resembles the PSI template.
% \usecolortheme{whale}
%\usecolortheme{wolverine}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
% \setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line
}

\setbeamertemplate{sections/subsections in toc}[sections numbered]  % Controls style of number in the table of contents.

% Packages:
\usepackage{pgfgantt}
\usepackage{colortbl}
\usepackage{pifont}
\usepackage{adjustbox}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{animate}
\usepackage{appendixnumberbeamer}
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{cancel}
%\usepackage{dutchcal}
% \usepackage{enumitem}
\usepackage[shortlabels]{enumitem}
\usepackage{float}
\usepackage{graphicx} % Allows including images
\usepackage{hhline}
\usepackage{listings}
% Theme choice
% \usetheme{AnnArbor}
% Required package
\usepackage{caption}
 %so that the captions are numerated
\setbeamertemplate{caption}[numbered]
\lstset{
  language=Python,
  basicstyle=\ttfamily,
  mathescape
}
\lstdefinestyle{CppStyle}{
  language=C++,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{orange}
}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{multimedia}
\usepackage[authoryear]{natbib}
\usepackage{scrextend}
\usepackage{pdfpages}
\changefontsizes{8pt}
\usepackage{siunitx}
\usepackage{soul}
\usepackage{tikz}
\usetikzlibrary{mindmap, trees, arrows, shapes, backgrounds, matrix, decorations.pathreplacing, decorations.pathmorphing, positioning, arrows.meta,plotmarks, calc}
\usepackage{verbatim}
\usepackage{xmpmulti}

% \bibliographystyle{unsrt}  % This style cites with numbers, e.g. [2]
\bibliographystyle{unsrtnat}  % This style cites with names, e.g. [Adelmann, 2019]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tikz stuff:
\usetikzlibrary{positioning}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes}
\usetikzlibrary{matrix, arrows,decorations.pathmorphing}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{fadings}
\usetikzlibrary{arrows.meta,bending}
\usepackage{tikzscale}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\setbeamertemplate{navigation symbols}{}  % Remove navigation symbols
\setbeamersize{text margin left=1cm,text margin right=1cm}

%% Maths definitions.
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\supp}{supp}
\DeclareMathOperator*{\Var}{\mathrm{Var}}
\DeclareMathOperator*{\Cov}{\mathrm{Cov}}
\DeclareMathOperator*{\E}{\mathbb{E}}
\DeclareMathOperator*{\MSE}{\text{MSE}}
\DeclareMathOperator*{\sgn}{\text{sgn}}
\DeclareMathOperator*{\Epsilon}{\mathcal{E}}
\DeclareMathOperator*{\bigO}{\mathcal{O}}
\DeclareMathOperator*{\smalls}{s}
\newcommand{\mvec}[1]{\boldsymbol{\1}}
\newcommand\underrel[2]{\mathrel{\mathop{\2}\limits_{\1}}}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Enter here author information:
\title[Electromagnetic Simulation]{Performance portable FDTD Implementation} % The short title appears at the bottom of every slide, the full title is only on the title page.

\author{\textbf{Manuel Winkler}, S. Mayani, A. Adelmann}
\institute[PSI]{
AMAS Group, LSM\\ % Your institution for the title page.
}
\date{\today}

\def \myEmail {flaschenholz@protonmail.ch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\frametitlepsi}[1]{\frametitle{\hspace{0.8cm}\includegraphics[width=1.5cm]{logos/PSI.pdf}\hspace{1.1cm} \1}}

\begin{document}
\setbeamertemplate{caption}{\raggedright\insertcaption\par}
\def\vfilll{\vskip 0pt plus 1filll minus 0pt }
\begin{frame}
  % Title page image:
  \vspace{0.3cm}
  \begin{adjustbox}{width=\paperwidth, center}
    \begin{tikzpicture}
      \centering
      \filldraw[fill=lightgray!40!white, draw = none] (0,0) rectangle (3.3,0.5\textheight);
      % Logos:
      \node[anchor=south west,inner sep=0] at (0.4,3.4)
           {\includegraphics[width=2.5cm]{logos/PSI.pdf}};
      \node[anchor=south west,inner sep=0] at (0.5,1.8)
           {\includegraphics[width=2.4cm]{logos/eth_logo_kurz_pos.eps}};
    \end{tikzpicture}
    \begin{tikzpicture}
      \node (heli) [anchor=south west,inner sep=0] at (0,0)
            {\includegraphics[height=0.5\textheight]{logos/PSI_helicopter}};
      \node [anchor=south west, inner sep = 1,fill=white, opacity=0.8] at (3.5, 0.0)
            {\tiny WIR SCHAFFEN WISSEN - HEUTE FÜR MORGEN};
    \end{tikzpicture}
    \begin{tikzpicture}
      \filldraw[fill=lightgray!40!white, draw = none] (0,0) rectangle (1,0.5\textheight);
    \end{tikzpicture}
  \end{adjustbox}
  \vspace{0.1cm}\\
  {\usebeamerfont{subtitle} \footnotesize \insertauthor\, ::  \insertinstitute}
  \vspace{0.4cm}
  {\usebeamerfont{title} \LARGE \inserttitle}\\
  \vspace{0.4cm}
  {\usebeamerfont{subtitle} \footnotesize \insertdate}\\
  \vfilll
  \null\hfill\tiny Contact: \url{\myEmail}
\end{frame}

% Table of contents slide, comment this block out to remove it.
\begin{frame}[noframenumbering]
\frametitle{Overview}
\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation.
\end{frame}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------
\section{Governing equations}
\frame[noframenumbering]{\tableofcontents[currentsection]}
\begin{frame}
{\huge Field Update}
Define the four potential $A^\alpha = \left(\phi, \mathbf{A}\right)$ which evolves according to a wave equation:
\begin{align*}
\frac{\partial^2 A^\alpha}{\partial t^2} &= \Delta A^\alpha + S^\alpha \\
\text{where } S^\alpha &= \left(\rho, \mathbf{J}\right)
\end{align*}
\pause
The magnetic and electric fields can be evaluated with
\begin{align*}
\mathbf{E} &= -\nabla \phi - \frac{\partial \mathbf{A}}{\partial t} \\
\mathbf{B} &= \nabla \times \mathbf{A}
\end{align*}
\end{frame}
\section{Field Discretization}
\frame[noframenumbering]{\tableofcontents[currentsection]}
\begin{frame}
    \frametitle{Stencil}
Use a three-point second derivative stencil:
\begin{align*}
\frac{\partial^2 A^\alpha}{\partial \beta^2}(\vec{x}) \approx \frac{1}{\beta^2}\left(A^\alpha(\vec{x} + \beta)
 - 2 A^\alpha(\vec{x}) + A^\alpha(\vec{x} - \beta)\right)
\end{align*}
where $\beta$ is an arbitrary vector. \\
In a cartesian grid this simplifies to
\begin{align*}
    \frac{\partial^2 A^\alpha}{\partial x^2}(\vec{x}) \approx\frac{1}{\Delta x^2}\left(A^\alpha_{i+1,...} - 2 A^\alpha_{i,...} + A^\alpha_{i-1,...}\right)
\end{align*}
where $i$ is the index corresponding to the direction of $x_$

\end{frame}
\begin{frame}
\frametitle{FDTD Formulation}
  \begin{align*}
      \frac{\partial^2 \psi(x, y, z, t)}{\partial x^2} &=
      \frac{\psi^n_{i+1,j,k} - 2\psi^n_{i,j,k} + \psi^n_{i-1,j,k}}{\Delta x^2} \\
      \frac{\partial^2 \psi(x, y, z, t)}{\partial y^2} &=
      \frac{\psi^n_{i,j+1,k} - 2\psi^n_{i,j,k} + \psi^n_{i,j-1,k}}{\Delta y^2} \\
      \frac{\partial^2 \psi(x, y, z, t)}{\partial z^2} &=
      \frac{\psi^n_{i,j,k+1} - 2\psi^n_{i,j,k} + \psi^n_{i,j,k-1}}{\Delta z^2} \\
      \frac{\partial^2 \psi(x, y, z, t)}{\partial t^2} &=
      \frac{\psi^{n+1}_{i,j,k} - 2\psi^n_{i,j,k} + \psi^{n-1}_{i,j,k}}{\Delta t^2}
  \end{align*}
where $\psi$ represents a component of the four-potential.\\
\pause
\vspace{1cm}
Only unknown: $\psi^{n+1}_{i,j,k}$.
\end{frame}

\begin{frame}
    \frametitle{Accuracy Analysis}
Consider the one-dimensional analytical function around $x_0 = 0$
\begin{align*}
f(x) &= f(0) + x f'(0) + \frac{x^2}{2}f''(0) + \frac{x^3}{6}f'''(0) + \frac{x^4}{24}f''''(0) + \mathcal{O}(\Delta x^5)
\end{align*}
%\begin{align*}
%\frac{\partial^2 f}{\partial x^2} &= \frac{1}{\Delta x ^ 2}\left(f_{i + 1} - 2 f_{i} + f_{i - 1}\right)
%\end{align*}
\pause
We can add the evaluations at $\pm \Delta x$ and subtract twice the evaluation at $0$:
\begin{align*}
& f(\Delta x) + f(-\Delta x) - 2 f(0) = \\
\end{align*}
\pause
\begin{align*}
&  \hphantom{2} f(0) + \Delta x f'(0) + \frac{\Delta x ^ 2}{2}f''(0) + \frac{\Delta x ^ 3}{6}f'''(0) + \frac{\Delta x ^ 4}{24}f''''(0) + \mathcal{O}(\Delta x^5) \\
+& \hphantom{2} f(0) - \Delta x f'(0) + \frac{\Delta x ^ 2}{2}f''(0) - \frac{\Delta x ^ 3}{6}f'''(0) + \frac{\Delta x ^ 4}{24}f''''(0) + \mathcal{O}(\Delta x^5) \\
-& 2f(0) = \Delta x ^ 2 f''(0) +  \frac{\Delta x ^ 4}{12}f''''(0) + \mathcal{O}_E(\Delta x^6)
\end{align*}
where $\mathcal{O}_E$ implies only even terms.
\end{frame}
\begin{frame}
  {\huge Accuracy Analysis}
We therefore can see that 
\begin{align*}
\frac{1}{\Delta x^2} \left(f(\Delta x) + f(-\Delta x) - 2 f(0) \right) = f''(0) + \frac{\Delta x ^ 2}{12}f''''(0) + \mathcal{O}_E(\Delta x^4)
\end{align*}
approximates the second derivative of $f$ in $0$ with an error that is proportional to $f''''(0)$
\end{frame}
\begin{frame}
  {\huge First test case}
  Consider the 1D wave equation 
\begin{align*}
  \frac{\partial^2 f}{\partial x^2} &= \frac{\partial^2 f}{\partial t^2} \\ 
  f(t = 0, x) &= \sin(\pi x)
\end{align*}
with periodic boundary conditions defined on $[-1, 1]$.\\
\pause
Analytical solution:
\begin{align*}
f(t, x) &= \hphantom{\pi^4} \sin(\pi x)\cos(\pi t) \\
\text{implying } \frac{\partial^4 f}{\partial x^4}(0) &= \pi^4 \sin(\pi x) \cos(\pi t) \\
\text {and } f(1, x) &= -\sin(\pi x)
\end{align*}
Evolving this equation numerically with $\Delta x \neq \Delta t$ up to $t = 1$ yields
\begin{align*}
f_n(1, x) = -\sin(\pi x) + k\frac{\Delta t}{\Delta t}(\Delta x^2) + \mathcal{O}(\Delta x^4)
\end{align*}
\end{frame}
\begin{frame}
  {\huge First test case}
  Due to linearity, we can separate the evolution of the exact solution and the error.
  \begin{align*}
  f_n(1, x) &= -\sin(\pi x) + k\Delta x^2 + \mathcal{O}_E(\Delta x^4) \\
  \implies f_n(2, x) &= \hphantom{-} \sin(\pi x) - k\Delta x^2 + k\Delta x^2 + \mathcal{O}_{12}(\Delta x^4) + \mathcal{O}_E(\Delta x^4) \\
                     &= \hphantom{-} \sin(\pi x) + \mathcal{O}_{\hphantom{1}}(\Delta x^4) 
  \end{align*}
  \pause
  \includegraphics[width=\textwidth]{wave_error_cubic.pdf}
\end{frame}
\begin{frame}
  Additionally, in the case of $\Delta t = \Delta x$, the numerical wave operator
  \begin{align*}
  \frac{1}{\Delta x^2}\left(A^\alpha_{i+1,...} - 2 A^\alpha_{i,...} + A^\alpha_{i-1,...}\right) - \frac{1}{\Delta t^2}\left(A^\alpha_{...,n+1} - 2 A^\alpha_{...,n} + A^\alpha_{...,n-1}\right)
  \end{align*}
  reduces to zero for the exact solution
  \begin{align*}
    f(t, x) &= \sin(\pi x)\cos(\pi t)
  \end{align*}
  \pause
  because the even derivatives cancel:
  \begin{align*}
    \frac{\partial ^ {2n}f(t, x)}{\partial t^{2n}} &= \frac{\partial ^ {2n}f(t, x)}{\partial x^{2n}} = \pi ^ {2n}\sin(\pi x)\cos(\pi t)
  \end{align*}
\end{frame}
\begin{frame}
  {\huge Exact stepper}
  This results in machine precision accuracy for any grid spacing:
  \includegraphics[width=\textwidth]{wave_error_machine.pdf}
\end{frame}
\begin{frame}
\frametitle{Boundary conditions}
Absorbing boundary conditions: Custom timestep rule on the boundary.

\vspace{1em}
Mathematical formulation:
\begin{align}
\left(\frac{\partial}{\partial x} - \frac{\partial}{\partial t}\right)\psi\bigg\rvert_{x = 0} &= 0 \text{ according to \cite{Mur1981}} \\
\vspace{2cm}\left(\frac{\partial^2}{\partial x \partial t} - \frac{\partial^2}{\partial t^2}\right)\psi\bigg\rvert_{x = 0} &= 0 \text{ according to according to \cite{fallahi2020mithra}} \label{fallahiabc}
\end{align}
\pause
Equation \ref{fallahiabc} can be used for boundaries with $\frac{\partial \psi}{\partial x}$, i.e. external fields:
\begin{align*}
\mathbf{E} &= \mathbf{e}_x \\
\matbf{\phi} &= x
\end{align*}
is a stationary solution only for \ref{fallahiabc}.
\end{frame}
\begin{frame}
\frametitle{Initial conditions}
For an initial source term
\begin{align*}
S &= \begin{bmatrix} \rho_0 \\ 0 \\ 0 \\ 0 \end{bmatrix}
\end{align*}
we solve the poisson equation
\begin{align*}
-\Delta \phi &= \rho_0
\end{align*}
\pause
For inital conditions with one moving particle:
\begin{align*}
\phi(\vec{r}, 0) &= \frac{q}{4 \pi(1 - \vec{\beta} \cdot \vec{n}) ||\vec{r} - \vec{R}(t_{ret})||} \\
\text{and } \mathbf{A}(\vec{r}, 0) &= \phi(r, 0) \vec{\beta}_{ret} \\ \\
\text{where } t_{ret} &= -||\vec{r} - \vec{R}(t_{ret})|| 
\end{align*}
\pause
For $p$ particles and $n$ gridpoints: $\mathcal{O}(p\cdot n)$!
\end{frame}
\section{Particle Discretization and Interpolation}
\frame[noframenumbering]{\tableofcontents[currentsection]}
\begin{frame}
  {\huge Particle Update}
  Lorentz Force:
\begin{align*}
  \vec{F_L} = q \mathbf{E} + q \vec{v} \times \mathbf{B} \\
\end{align*}
Lorentz acceleration:
\begin{align*}
  \vec{a_L} = \frac{q}{m_r} \mathbf{E} + q \vec{v} \times \mathbf{B} \\
  \text{where } m_r = \gamma m_0
\end{align*}
\end{frame}

\begin{frame}
  \frametitle{Particle timestep}
Boris update scheme with boosted $E$ and $B$: \cite{fallahi2020mithra}\\
\begin{align*}
  \left(r^m, \gamma \beta ^ {m - \frac{1}{2}}\right) &\rightarrow \left(r^{m + 1}, \gamma \beta ^ {m + \frac{1}{2}}\right) \\ \\
  \mathbf{t}_1 &= \gamma \mathbf{\beta}^{m - \frac 1 2} + \frac{e \Delta t_b \mathbf{E}_t^m}{2 m} \\
  &\vdots \\
  %\mathbf{t}_2 &= t_1 + \alpha t_1 \times \mathbf{B}_t^m \\
  %\mathbf{t}_3 &= t_1 + t_2 \times \frac{2 \alpha \mathbf{B}_t^m }{1 + \alpha^2 \mathbf{B}_t^m \cdot \mathbf{B}_t^m} \\
  %\gamma \mathbf{\beta}^{m + \frac 1 2} &= t_3 + \frac{e \Delta t_b \mathbf{E}_t^m}{2 m} \\
  \mathbf{r}^{m + 1} &= r^m + \frac{\Delta t_b \gamma \bm{\beta}^{m + \frac 1 2}}{\sqrt{1 + \lVert\gamma \mathbf{\beta}^{m + \frac 1 2}\rVert^2}} \\
  %\text{where } \alpha &= \frac{e \Delta t_b}{2m\sqrt{1 + \lVert t_1 \rVert^2}}
\end{align*}
\pause
Note that \\
\begin{align*}
\beta &= \frac{\gamma \beta}{\sqrt{1 + \lVert \gamma \beta \rVert^2}} \\
\gamma &= \sqrt{1 + \lVert \gamma \beta \rVert^2}
\end{align*}
\end{frame}
\begin{frame}
  \frametitle{Test of Boris Stepper}
  Setup: Shoot charged particle in constant $z$-aligned magnetic field\\
  \begin{minipage}{0.45\textwidth}
    \centering
  \includegraphics[width=\columnwidth]{trajectory_constant.pdf}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
  
  \begin{itemize}
    \item[$\cdot$] Traces a perfect circle
    \item[$\cdot$] Conserves energy up to machine precision
  \end{itemize}
\end{minipage}
\end{frame}
%\begin{frame}
%{\huge Particle to Grid interpolation}
%For an particle $p$ with position components
%\begin{align*}
%r &= \begin{bmatrix} \vdots \\ r_i \\ \vdots \end{bmatrix}, r_i = \lfloor \frac{r_i}{\Delta x_i}\rfloor \Delta x_i + \delta x_i = \alpha_i \Delta x_i + \delta x_i\\
%i \in \{0, N-1\} 
%\end{align*}
%the attribute $\rho$ is scattered to the $2^N$ nearest gridpoints with weights
%\begin{align*}
%\rho^p_{\alpha_0 + d_0,\alpha_1 + d_1,...} &= \prod_i^{N - 1} \left(d_i + \left[-\frac{\delta x_i}{\Delta x_i}\right]^{d_i}\right) \\
%\begin{bmatrix} \vdots \\ d_i \\ \vdots \end{bmatrix} &\in \{0, 1\}^N
%\end{align*}
%\end{frame}



\begin{frame}{Particle Discretization}
  Interpolation of a particle attribute to the grid: For a particle with position
  {\scriptsize
  \begin{align}
  p &= \begin{bmatrix} p_x \\ p_y \\ p_z \end{bmatrix} = \begin{bmatrix}
      \left \lfloor{\frac{p_x}{\Delta x}}\right \rfloor \Delta x + \delta_x \\
      \left \lfloor{\frac{p_y}{\Delta y}}\right \rfloor \Delta y + \delta_y \\ 
      \left \lfloor{\frac{p_z}{\Delta z}}\right \rfloor \Delta z + \delta_z \end{bmatrix} = 
  \begin{bmatrix} i \Delta x + \delta_x \\ j \Delta x + \delta_y \\ k \Delta x + \delta_z \end{bmatrix}
  \end{align}
  }%
  the Cloud-In-Cell interpolation is done as follows
  {\scriptsize
  \begin{align}
  \rho^p_{i+I,j+J,k+K} &= \rho\left(\frac{1}{2} + (-1)^I \bigg\rvert \frac{1}{2} - \frac{\delta x}{\Delta x} \bigg\rvert \right)
                              \left(\frac{1}{2} + (-1)^J \bigg\rvert \frac{1}{2} - \frac{\delta y}{\Delta y} \bigg\rvert \right)
                              \left(\frac{1}{2} + (-1)^K \bigg\rvert \frac{1}{2} - \frac{\delta z}{\Delta z} \bigg\rvert \right)
  \end{align}
  with $(I,J,K) \in \{0,1\}^3$.
  }%
  \end{frame}
  \begin{frame}
  \frametitle{Gathering field attributes}
  Interpolating field attributes to particles works analogously:
  {\scriptsize
  \begin{align*}
      \psi^p &= \sum_{I,I,K \in \{0,1\}^3} \psi \left(\frac{1}{2} + (-1)^I \bigg\rvert \frac{1}{2} - \frac{\delta x}{\Delta x} \bigg\rvert \right)
                                                \left(\frac{1}{2} + (-1)^J \bigg\rvert \frac{1}{2} - \frac{\delta y}{\Delta y} \bigg\rvert \right)
                                                \left(\frac{1}{2} + (-1)^K \bigg\rvert \frac{1}{2} - \frac{\delta z}{\Delta z} \bigg\rvert \right)
  \end{align*}
  }%
  \end{frame}
  \begin{frame}
  \frametitle{Current Deposition}
  Cloud-In-Cell deposition of current: 
  We define the deposition point $p^m$ as the midpoint between two adjacent timesteps:
  {\scriptsize
  \begin{align}
  p^m &= \begin{bmatrix} \frac{p_x^n + p_x^{n+1}}{2} \\ \frac{p_y^n + p_y^{n+1}}{2} \\ \frac{p_z^n + p_z^{n+1}}{2} \end{bmatrix} = 
  \begin{bmatrix} 
  \left \lfloor{\frac{p^m_x}{\Delta x}}\right \rfloor \Delta x + \delta_x \\ 
  \left \lfloor{\frac{p^m_y}{\Delta y}}\right \rfloor \Delta y + \delta_y \\ 
  \left \lfloor{\frac{p^m_z}{\Delta z}}\right \rfloor \Delta z + \delta_z \end{bmatrix}
  \end{align}
  }%
  {\scriptsize
  \begin{align}
  \mathbf{J}^p_{i+I,j+J,k+K} &= \rho\mathbf{v}\left(\frac{1}{2} + (-1)^I \bigg\rvert \frac{1}{2} - \frac{\delta x}{\Delta x} \bigg\rvert \right)
                                    \left(\frac{1}{2} + (-1)^J \bigg\rvert \frac{1}{2} - \frac{\delta y}{\Delta y} \bigg\rvert \right)
                                    \left(\frac{1}{2} + (-1)^K \bigg\rvert \frac{1}{2} - \frac{\delta z}{\Delta z} \bigg\rvert \right) \\
                                    \text{where } \mathbf{v} &= \frac{r^{m + 1} - r^{m - 1}}{2 \Delta t}
  \end{align}
  }%
  \pause
  If a particle travels across a cell boundary, this scheme violates
  {\scriptsize
  \begin{align}
  \nabla \cdot \mathbf{E} &= \rho
  \end{align}
  }%
  \end{frame}
  \begin{frame}
  \frametitle{Boris Correction}
  To satisfy
  \begin{align*}
  \nabla \cdot \mathbf{E} &= \rho
  \end{align*}
  we simply add a correction term equivalent to the negative error \cite{Lund2016}:
  \begin{align}
  \mathbf{E'} &= \mathbf{E} - \nabla\delta\phi \text{ with } \nabla \cdot \left(\nabla\delta\phi\right) = \nabla \cdot \mathbf{E} - \rho
  \end{align}
  \end{frame}
  \begin{frame}
  \frametitle{Zigzag Current Deposition}
  Alternatively change current deposition scheme: Particle motion from $p_1$ to $p_2$ is decomposed into two separate movements, $p_1$ to $p_r$ and $p_r$ to $p_2$ \cite{fallahi2020mithra}.
  {\scriptsize
  \begin{align*}
      x_r &= \min\left(\min(i_1\Delta x, i_2 \Delta x) + \Delta_x, \max\left(\min(i_1\Delta x, i_2 \Delta x), \frac{x_1 + x_2}{2}\right)\right)\\
      y_r &= \min\left(\min(j_1\Delta x, j_2 \Delta y) + \Delta_y, \max\left(\min(j_1\Delta y, j_2 \Delta y), \frac{y_1 + y_2}{2}\right)\right)\\
      z_r &= \min\left(\min(k_1\Delta x, k_2 \Delta z) + \Delta_z, \max\left(\min(k_1\Delta z, k_2 \Delta z), \frac{z_1 + z_2}{2}\right)\right)
  \end{align*}
  }%
  Then two Cloud-In-Cell interpolations of with points $\frac{p_1 + p_r}{2}$ and $\frac{p_r + p_2}{2}$ \cite{UMEDA200373} satisfy the conservation of current.
  \end{frame}

\begin{frame}
  
  \frametitle{Test of current deposition and field update}
  Idea: Compare simulated radiation to Larmor:
  \begin{align*}
    P &= \frac{q^2}{6\pi}\gamma^6(||\dot {\vec \beta}||^2 - ||\vec\beta \times \dot{\vec \beta}||^2)
  \end{align*}
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{figure}[h] 
      \centering
      \includegraphics[width=\columnwidth]{radplot_badres.pdf}
      \caption{$\sigma_{init}$ = 0.02}
      \label{fig:bigvar}
    \end{figure}
  \end{minipage}
  \hfill
  \begin{minipage}{0.5\textwidth}
  
  Setup:
  \begin{itemize}
    \item[$\cdot$] Initialize particles with gaussian distribution
    \item[$\cdot$] Rotate particles around center with fixed speed.
  \end{itemize} 
  \pause
  Observations:
  \begin{itemize}
    \item[$\cdot$] Constant outward radiation
    \item[$\cdot$] Different particle trajectories interfere destructively
  \end{itemize}
\end{minipage}
\end{frame}
\begin{frame}
  \frametitle{Test of current deposition and field update}
  \begin{minipage}{0.45\textwidth}
    \begin{figure}[h]
      \centering
      \includegraphics[width=\columnwidth]{radplot_goodres.pdf}
      \caption{$\sigma_{init}$ = 0.005}
      \label{fig:smallvar}
    \end{figure}
  \end{minipage}
  \hfill
  \begin{minipage}{0.5\textwidth}
  
  Setup:
  \begin{itemize}
    \item[\cdot] Initialize particles with gaussian distribution
    \item[\cdot] Rotate particles around center with fixed speed.
  \end{itemize} 
  Observations:
  \begin{itemize}
    \item[\cdot] Constant outward radiation
    \item[\cdot] Different particle trajectories interfere destructively
  \end{itemize}
\end{minipage}
\end{frame}
\begin{frame}
  \frametitle{Test of coupled field and particle update}
  \begin{minipage}{0.45\textwidth}
    \begin{figure}[h]
      \centering
      \includegraphics[width=\columnwidth]{trajectory_radiatinggood.pdf}
      \caption{$\sigma_{init}$ = 0.0}
      \label{fig:smallvar}
    \end{figure}
  \end{minipage}
  \hfill
  \begin{minipage}{0.5\textwidth}
  
  Setup:
  \begin{itemize}
    \item[\cdot] Initialize particles with gaussian distribution
    \item[\cdot] Let particles be guided by Lorentz force
  \end{itemize} 
  Observations:
  \begin{itemize}
    \item[\cdot] Particle progressively loses energy and spirals inward
  \end{itemize}
\end{minipage}


\end{frame}


\begin{frame}
  \frametitle{Test of coupled field and particle update}
  \begin{minipage}{0.45\textwidth}
    \begin{figure}[h]
      \centering
      \includegraphics[width=\columnwidth]{radplot_lorentz.pdf}
      \caption{\sigma_{init} = 0.0}
      \label{fig:smallvar}
    \end{figure}
  \end{minipage}
  \hfill
  \begin{minipage}{0.5\textwidth}
  
  Setup:
  \begin{itemize}
    \item[\cdot] Initialize particles with gaussian distribution
    \item[\cdot] Let particles be guided by Lorentz force
  \end{itemize} 
  Observations:
  \begin{itemize}
    \item[\cdot] Constant outward radiation up until all energy is lost
  \end{itemize}
\end{minipage}
\end{frame}
\section{Outlook}
\frame[noframenumbering]{\tableofcontents[currentsection]}
\begin{frame}[fragile]
\frametitle{Undulators and Lorentz boosts}
Transformation of undulator fields:
\begin{align*}
\mathbf{B}_{lab}(\mathbf{r}) = \begin{bmatrix} 0 \\ B_0 \cosh{(k \cdot y_{lab})} \sin{(k \cdot z_{lab})} \\ B_0 \sinh{(k \cdot y_{lab})} \cos{(k \cdot z_{lab})} \end{bmatrix}
\end{align*}
\pause
\begin{align*}
  r_{lab} &= \mathbf{\Lambda}^{-1}(r_{bunch}) \\
  \mathbf{E}_{bunch} &= \gamma(\mathbf{E}_{lab} + \mathbf{v} \times \mathbf{B}_{lab}) - (\gamma - 1)\left(\mathbf{E}_{lab} \cdot \frac{\mathbf{v}}{||\mathbf{v}||}\right) \\
  \mathbf{B}_{bunch} &= \gamma(\mathbf{B}_{lab} - \mathbf{v} \times \mathbf{E}_{lab}) - (\gamma - 1)\left(\mathbf{B}_{lab} \cdot \frac{\mathbf{v}}{||\mathbf{v}||}\right) \\
  \text{or equivalently  } \mathbf{F}^{\alpha\beta}_{bunch} &= \mathbf{\Lambda}^\beta_\alpha \mathbf{F}^{\alpha \beta}_{lab}\mathbf{\Lambda}_\beta^\alpha
\end{align*}
%\end{frame}
%\begin{frame}[fragile]
In code:
\begin{lstlisting}[style=CppStyle]
{
  lorentzBoost<double> boost({0.0, 0.0, 0.99});
                                  //Lab to bunch frame
  ippl::Matrix<double, 4, 4> mat = boost.unprimedToPrimed();
}
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Resampling}
Assign weight $w_i$ to each particle $p_i$.
\pause
Resampling must conserve:
\begin{align*}
  \sum _{i = 1} ^ {N_{b}} w^b_i &= \sum _{j = 1} ^ {N_{a}} w^a_j
\end{align*}
The "true" quantity $q$ of particle $p_i$ is given by $\rho_i \cdot w_i$. \\
\pause
\vspace{1cm}
Preferrably also conserve 
\begin{align*}
\overline {\mathbf{r}} &= \sum _{i = 1} ^ {N}\frac{\mathbf{r_i}}{N} \text{    } \text{    (Center of mass)} \\
\sigma &= \sum _{i = 1} ^ {N}\frac{(\mathbf{r_i} - \overline {\mathbf{r}})}{N} \text{    } \text{    (Variance)} \\
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Bibliography}
%\bibliographystyle{IEEEtran}
\bibliography{references}
\end{frame}
\end{document}
\set math.vec(delim: "[")
\set math.mat(delim: "[")
\import "@preview/polylux:0.3.1": *
\import "@preview/cetz:0.2.2": canvas, draw, vector, matrix
\import "@preview/physica:0.9.3": pdv, vb, vecrow
\import "@preview/fletcher:0.4.4" as fletcher: diagram, node, edge
\let bv(it) = $vb(upright(it))$
\set cite(style: "the-institution-of-engineering-and-technology")
//\import "tests.typ"
//\import themes.simple: *
//\set math.equation.numbering("(1)")
\let authors = {"Author"}
\import themes.university: *
\let fstate = "New Computer Modern"
\if sys.inputs.keys().contains("font"){
  fstate = sys.inputs.at("font")
}
\set text(font: fstate)
\show: university-theme.with(aspect-ratio: "4-3"
  //it => [it]
)

\let author_state = state("author", "John Doe")
\let coauthors_state = state("coauthors", "")
\let title_state = state("title", "Science")
\let bottomgraybar = place(dx: 0%, dy: 100% - 18pt)[\rect(height: 19pt, width: 100%, stroke: none, fill: rgb("ccccff"))[
  \set text(size: 14pt, font: "New Computer Modern")
  \grid(rows: (1fr), columns: (1.7fr, 1fr, 1fr),
  align(horizon + left,pad(x: 5pt, y:0pt)[\text(text(weight: 900)[\author_state.display()]/* + text(weight: 300)[\coauthors_state.display()]*/)]),
  align(horizon + left, pad(x: 0pt, y:0pt)[Final Presentation]),
  align(horizon + right, pad(x: 5pt, y:0pt)[\datetime.today().display("[month repr:long] [day], [year]") \h(1cm) \text(logic.logical-slide.display() + [~/~] + utils.last-slide-number)]))
]]
\let equationbox(stroke: black, content) = box(width: 100%, align(center, box(stroke: 2pt + stroke, outset: 5pt, inset:5pt, radius: 5pt)[
  \content
]))
\let topgraybar(content) = place(dx: 0%, dy: 0%)[\rect(height: 60pt, width: 100%, stroke: none, fill: rgb("ccccff"))[
  \set text(size: 40pt)
  \align(horizon + left, h(5pt) + content)
]]
//\page(background: block(width: 100%, height: 100%)
\let titelsleid(title_image_height : 48%, showimage: false, author: "John Doe", email : "", coauthors : (), title : "Science", groupname : "SomeGroup") = {polylux-slide[
  \place(dx: 0%, dy: 6%, rect(stroke: 0pt, fill: rgb("dddddd"), width: 28%, height: title_image_height)[
    \place(dy: 7%)[\block(width: 100%, height: 100%, align(top + center, image("logos/PSI.png", width: 60%)))]
    \place(dy: 40%)[\block(width: 100%, height: 100%, align(top + center, image("logos/eth.png", width: 60%)))]
  ])
  \place(dx: 90%, dy: 6%, rect(stroke: 0pt, fill: rgb("dddddd"), width: 10%, height: title_image_height))
  \if showimage [
    \place(dx: 30%, dy: 6%, box(height: title_image_height)[
      \let tv = text(font: "Noto Serif", size: 10pt, "WIR SCHAFFEN WISSEN - HEUTE FÜR MORGEN")
      \image("logos/PSI_helicopter.jpg", height: 100%)
      \align(bottom + right, box(inset: 2pt, radius: 2pt, fill: rgb("cccccccc"), tv))
    ])
  ] else [
    \place(dx: 30%, dy: 6%, box(height: title_image_height)[
      \let tv = text(font: "Noto Serif", size: 10pt, "WIR SCHAFFEN WISSEN - HEUTE FÜR MORGEN")
      \rect(height: 100%, width: 15cm)
      \align(bottom + right, box(inset: 2pt, radius: 2pt, fill: rgb("cccccccc"), tv))
    ])
  ]
  \if email.len() > 0 [
    \place(dy: 88%)[
      \box(width: 100%)[
        \align(right)[
          \text(size: 13pt)[Email: \email \h(15%)]
        ]
      ]
    ]
  ]

  \let thing(body) = style(styles => {
    let size = measure(body, styles)
    text(size: 6pt)[Width of "\body" is \size.width]
  })
  
  \author_state.update(author)
  \title_state.update(title)
  \{
    let n = 0
    let str = "Advisors: "
    while n < coauthors.len() {
      if(n >= 1){
        str = str + ", "
      }
      str = str + coauthors.at(n)
      n = n + 1
    }
    coauthors_state.update(str)
    text(size: 15pt, weight: 300)[]
  }
  \bottomgraybar
  //\place(dx: 0%, dy: 0%, rect(stroke: 0pt, fill: gray, width: 200pt, height: 50pt))
  
//])[
  \grid(rows:(4fr, 2fr), columns: (1fr))[][
    \place(dx: 15%)[
      \stack(spacing: 30pt,
        block(text(size: 15pt, weight: 900)[\author_state.display()] + text(size: 15pt, weight: 400)[\h(10pt) :: \h(10pt) \groupname] + text(size: 13pt, weight: 300)[ \ \coauthors_state.display()] + text(size: 15pt, weight: 300)[]),
        text()[\title_state.display()],
        text(size: 15pt)[\datetime.today().display("[month repr:long] [day], [year]")]
      )
    ]
  ]
]}
\let normalislide(padding: 3cm, title : "", content) = {
  polylux-slide()[
    \bottomgraybar
    \topgraybar()[\title]
    \pad(x: padding, block(width: 100%, height: 100%, align(horizon, content)))
  ]
}
\let newsectionslide(title : "", content) = {
  utils.register-section(title)
  polylux-slide()[
    \bottomgraybar
    \topgraybar()[\title]
    \pad(x: 4cm, block(width: 100%, height: 100%)[
      \show title: it => {text(weight: 900, fill: rgb("5555bb"), it)}
      \align(horizon, polylux-outline())
    ])
  ]
  
}
\let newsectionslide_nocontents(title : "", content) = {
  utils.register-section(title)
  polylux-slide()[
    \topgraybar()[\title]
    \pad(x: 4cm, block(width: 100%, height: 100%)[
      \align(horizon, content)
    ])
  ]
}
\let sections-state = state("polylux-sections", ())
\let cool-outline(enum-args: (:), spacing : 0cm, padding: 0pt) = locate( loc => {
  let sections = sections-state.final(loc)
  pad(padding, enum(
    ..enum-args,
    ..sections.map(section => link(section.loc, section.body + v(spacing)))
  ))
})



\titelsleid(title_image_height: 50%, author: "Manuel Winkler", email: "flaschenholz@protonmail.com", coauthors : ("Sonali Mayani", text(tracking: -0.0em)[Andreas Adelmann], text(tracking: -0.0em)[Sriramkrishnan Muralikrishnan], [Arnau Albà], "Arya Fallahi"), title : [A performance portable FDTD implementation \ Final Presentation], groupname : "AMAS Group, LSM", showimage:true)
\normalislide(title: "Outline")[
  \cool-outline()
]
//\let vr(..it) = $vecrow(..(it))$
\newsectionslide(title: "Methodology")[]
\normalislide(title: "The PIC Loop")[
\set text(0.8em)
\diagram(
  node-stroke: .1em,
  node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%),
  spacing: 1cm,
  node((0,1), [Update particles], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((1,0), [Interpolate Particles \ to grid], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((0,-1), [Update Four-Potential], height: 4em, width: auto, shape: rect, corner-radius: 1em, fill: gradient.radial(red.lighten(80%), red, center: (30%, 20%), radius: 80%)),
  node((-1,0), [Interpolate E and B \ fields to particles], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  edge((-1,0), (0,1), "-|>", bend: -40deg),
  edge((0,0.8), (1,0), "-|>", bend: -40deg),
  edge((1,0), (0,-1), "-|>", bend: -40deg),
  edge((0,-1), (-1,0), "-|>", bend: -40deg),
)
]
\normalislide(title: "Wave Equation")[
  We solve the vector wave equation
  $ laplace bv(A) = pdv(bv(A),t,2) + bv(J) $
  \pause
  where $ bv(A) &= vecrow(delim: "[", phi, A_0, A_1, A_2)^T \
          bv(J) &= vecrow(delim: "[", rho, J_x, J_y, J_z)^T $
  \pause
  \box(width: 1em, )[$bv(A)$] is stored and updated on a grid. \
  \box(width: 1em, )[$bv(J)$] is obtained from particles.
]
\normalislide(title: "Discretization")[
  For $bv(A)$:

  \let vpot = $bv(A)$
  \par(leading: 1.5em)[
  $ pdv(vpot^n_(i,j,k), x, 2) &= (vpot^n_(i+1,j,k) - 2vpot^n_(i,j,k) + vpot^n_(i-1,j,k)) / (Delta x^2) \
    pdv(vpot^n_(i,j,k), t, 2) &= (vpot^(n+1)_(i,j,k) - 2vpot^n_(i,j,k) + vpot^(n-1)_(i,j,k)) / (Delta t^2) $]
  \pause
  \
  And we solve for $vpot^(n+1)_(i,j,k)$.@fallahi2020mithra
]
\normalislide(title: [Standard Finite Differences])[
\show math.psi: $bv(A)$
  \let alpha1 = $alpha_1$
  \let alpha2 = $alpha_2$
  \let alpha4 = $alpha_4$
  \let alpha6 = $alpha_6$
  \let alpha8 = $alpha_8$
  \let vpot = $bv(A)$
  $ vpot^(n+1)_(i,j,k) = &- vpot^(n-1)_(i,j,k) 
  +  alpha1 vpot^n_(i,j,k) 
  +  alpha2 vpot^n_(i+1,j,k) 
  +  alpha2 vpot^n_(i-1,j,k)\ 
  + &alpha4 vpot^n_(i,j+,k) 
  +  alpha4 vpot^n_(i,j-1,k) 
  +  alpha6 vpot^n_(i,j,k+1) 
  +  alpha6 vpot^n_(i,j,k-1)\
  + &alpha8 upright(bold(J))^n_(i,j,k)
  $
  where
  \let ddx = $((c Delta t)/(Delta x))^2$
  \let ddy = $((c Delta t)/(Delta y))^2$
  \let ddz = $((c Delta t)/(Delta z))^2$
  \set text(0.9em)
  \let alpha1 = $2 lr((1 - ddx - ddy - ddz))$
  \let alpha2 = $ddx$
  \let alpha4 = $ddy$
  \let alpha6 = $ddz$
  \let alpha8 = $(c Delta t)^2$
  $ 
    alpha_1 &= alpha1 \
    alpha_2 &= alpha2,
    alpha_4 = alpha4,
    alpha_6 = alpha6 \
    alpha_8 &= alpha8 
  $
  $ Delta t <= min(Delta x,...) / sqrt(3) $
]
\normalislide(title: [Nonstandard Finite Differences])[
  \show math.psi: $bv(A)$
  $ 
psi_(i,j,k)^(n+1) &= -psi_(i,j,k)^(n-1)+ alpha'_1 psi_(i,j,k)^n \
&+ alpha'_2 ( cal(A) psi_(i+1,j,k-1)^n + (1-2cal(A)) psi_(i+1,j,k)^n &&&+ cal(A) psi_(i+1,j,k+1)^n &&&&) \
&+ alpha'_3 ( cal(A) psi_(i-1,j,k-1)^n + (1-2cal(A)) psi_(i-1,j,k)^n &&&+ cal(A) psi_(i-1,j,k+1)^n &&&&) \ 
&+ alpha'_4 ( cal(A) psi_(i,j+1,k-1)^n + (1-2cal(A)) psi_(i,j+1,k)^n &&&+ cal(A) psi_(i,j+1,k+1)^n &&&&) \
&+ alpha'_5 ( cal(A) psi_(i,j-1,k-1)^n + (1-2cal(A)) psi_(i,j-1,k)^n &&&+ cal(A) psi_(i,j-1,k+1)^n &&&&) \
&+ alpha'_6 psi_(i,j,k+1)^n + alpha'_7 psi_(i,j,k-1)^n + alpha'_8 vb(upright(J))_(i,j,k)^n$


]

\normalislide(title: [Nonstandard Finite Differences])[
   $
alpha'_1&=2 lr((1-(1-2 cal(A))((c Delta t)/(Delta x))^2-(1-2 cal(A))((c Delta t)/(Delta y))^2 - ((c Delta t)/(Delta z))^2 )) \
alpha'_2&=alpha'_3=((c Delta t)/(Delta x))^2,
alpha'_4 =alpha'_5=((c Delta t)/(Delta y))^2 \
alpha'_6&=alpha'_7=((c Delta t)/(Delta z))^2 - 2 cal(A) ((c Delta t)/(Delta x))^2 - 2 cal(A) ((c Delta t)/(Delta y))^2 \
alpha'_8&=(c Delta t )^2 \
$
 For $ cal(A) > 1/4, Delta t = Delta z $
]
\normalislide(title: [Absorbing Boundary Conditions])[
  $ (pdv(, x) - sqrt(1/c^2 pdv(, t, 2) - pdv(, y, 2) - pdv(, z, 2))) bv(A) = lr(0 " "|, size: \3.1em)_(x = 0) $
  \pause
  Discretize: 
  $ 
      plus.minus pdv(u, x) - 1/c &pdv(u, t)                                       &&= 0 " (first order)" , \
      plus.minus pdv(u, x, t) - 1/c &pdv(u, t, 2) - c/2 pdv(u, y, 2) - c/2 pdv(u, z, 2) &&= 0 " (second order)"
  $
]
\normalislide(title: [Initial Conditions])[
  \set math.cases(gap: 1em)
  $ cases("MITHRA: " bv(A) = 0, "Electrostatic: " laplace phi = rho |_(t=0)", " \h(1em) upright(A) = 0, "Liénard-Wiechert: " cases(display(Phi(vb(r), t) = q/(4 pi epsilon_0(1 - vb(beta)(t_"ret") dot vb(n))|r - vb(R)(t_"ret")|)), display(upright(A)(vb(r), t) = (vb(beta)(t_"ret"))/c Phi(vb(r), t)))) $
]
\normalislide(title: "The PIC Loop")[
\set text(0.8em)
\diagram(
  node-stroke: .1em,
  node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%),
  spacing: 1cm,
  node((0,1), [Update particles], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((1,0), [Interpolate Particles \ to grid], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((0,-1), [Update Four-Potential], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((-1,0), [Interpolate E and B \ fields to particles], height: 4em, width: auto, shape: rect, corner-radius: 1em, fill: gradient.radial(red.lighten(80%), red, center: (30%, 20%), radius: 80%)),
  edge((-1,0), (0,1), "-|>", bend: -40deg),
  edge((0,0.8), (1,0), "-|>", bend: -40deg),
  edge((1,0), (0,-1), "-|>", bend: -40deg),
  edge((0,-1), (-1,0), "-|>", bend: -40deg),
)
]
\normalislide(title: "Field Evaluation")[
  $ bv(A) &= vec(phi, upright(A)) \ \  
    bv(E) &= -nabla phi - pdv(upright(A),t) \ \ \
    bv(B) &= nabla times upright(A) $
]
\normalislide(title: "Particles")[
  \show "A": $upright(A)$
  $ bv(E)^n_(i,j,k) = 
  vec(-(phi_(i+1,j,k) - phi_(i-1,j,k)) / (2 Delta x) - (A^(n+1)_(x,i,j,k) - A^n_(x,i,j,k))/(Delta t),
      -(phi_(i,j+1,k) - phi_(i,j-1,k)) / (2 Delta y) - (A^(n+1)_(y,i,j,k) - A^n_(y,i,j,k))/(Delta t), 
      -(phi_(i,j,k+1) - phi_(i,j,k-1)) / (2 Delta z) - (A^(n+1)_(z,i,j,k) - A^n_(z,i,j,k))/(Delta t)) $
  \move(dx: 2.4cm)[
  $ bv(B)^n_(i,j,k) = 
  vec(
    (A_(z,i,j+1,k) - A_(z,i,j-1,k)) / (Delta y) - (A_(z,i,j,k+1) - A_(z,i,j,k-1)) / (Delta z),
    (A_(z,i,j,k+1) - A_(z,i,j,k-1)) / (Delta z) - (A_(z,i+1,j,k) - A_(z,i-1,j,k)) / (Delta x),
    (A_(z,i+1,j,k) - A_(z,i-1,j,k)) / (Delta x) - (A_(z,i,j+1,k) - A_(z,i,j-1,k)) / (Delta y),
  ) $]
]
\normalislide(title: "Particles")[
  \block[
  - Particles as discrete points with $m, q, vb(r), display(vb(p)/(c m)) = display(gamma vb(beta))$
  ]
  \pause
  \v(1em)
  \block[
  - $gamma = 2048 --> beta > 1 - epsilon_"fp32"$ \ (Our case: $gamma approx 100$, SwissFEL: $gamma approx 11350$)
  ]
  \pause
  \v(1em)
  \block[
  - \move(dy: -0.3em, block[Guided by Lorentz force: $display((dif vb(p)) / (dif t)) = q bv(E) + q vb(v) times bv(B)$])
  ]
]
\normalislide(title: "Grid to particle interpolation")[
  \set text(0.95em)
  \block(radius: 15pt, width: 100%, inset: 1em, stroke: 1pt)[
  \align(center, [Define interpolation indices @source_for_cic])
  $ vec(i_"int", j_"int", k_"int") &= vec(floor(r_x / (Delta x)), floor(r_y / (Delta y)), floor(r_z / (Delta z))) \ vec(delta x, delta y, delta z) &= vec(r_x / (Delta x) - i_"int", r_y / (Delta y) - j_"int", r_z / (Delta z) - k_"int") $]
  \pause
  \show math.equation: set text(font: "Libertinus Math", 0.8em)
  $ bv(F)_p = sum_(\text(1.3em)[$I,J,K in (0,1)^3$]) bv(F)_(i + I, j + J, k + K) (1/2 + (-1)^I abs(1/2 - (delta x) / (Delta x)))(1/2 + (-1)^J abs(1/2 - (delta y) / (Delta y)))(1/2 + (-1)^K abs(1/2 - (delta z) / (Delta z))) $
]
\normalislide(title: "The PIC Loop")[
\set text(0.8em)
\diagram(
  node-stroke: .1em,
  node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%),
  spacing: 1cm,
  node((0,1), [Update particles], height: 4em, width: auto, shape: rect, corner-radius: 1em,fill: gradient.radial(red.lighten(80%), red, center: (30%, 20%), radius: 80%)),
  node((1,0), [Interpolate Particles \ to grid], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((0,-1), [Update Four-Potential], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((-1,0), [Interpolate E and B \ fields to particles], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  edge((-1,0), (0,1), "-|>", bend: -40deg),
  edge((0,0.8), (1,0), "-|>", bend: -40deg),
  edge((1,0), (0,-1), "-|>", bend: -40deg),
  edge((0,-1), (-1,0), "-|>", bend: -40deg),
)
]
\normalislide(title: "Updating the particles")[
  \set text(0.95em)
  Governing equation:
  $ display((dif vb(p)) / (dif t)) = q bv(E) + q vb(v) times bv(B) $
  \pause
  \v(1cm)
  Update algorithm @boris1 @boris_whyisitsogood: $(gamma vb(beta)^(n - 1/2), vb(r)^n) --> (gamma vb(beta)^(n + 1/2), vb(r)^(n+1))$
  \let EF = $bv(E)$
  \let BF = $bv(B)$
  \show math.equation: set text(0.6em)
  $ t_1 &= gamma beta^(n - 1/2) + (q Delta t EF_t^n)/(2 m c) \
      alpha &= (q Delta t) / (2 m sqrt(1 + ||t_1||^2)) \
      t_2 &= t_1 + alpha t_1 times BF_t^n \
      t_3 &= t_1 + t_2 times (2 alpha BF_t^n) / (1 + alpha^2 ||BF_t^n||^2) \
      gamma beta^(n + 1/2) &= t_3 + (q Delta t EF_t^n) / (2 m c) \
      r^(m + 1) &= r^n + c Delta t (gamma beta^(m + 1/2)) / (sqrt(1 + ||gamma beta^(n + 1/2)||^2)) $
]
\normalislide(title: "The PIC Loop")[
\set text(0.8em)
\diagram(
  node-stroke: .1em,
  node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%),
  spacing: 1cm,
  node((0,1), [Update particles], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((1,0), [Interpolate Particles \ to grid], height: 4em, width: auto, shape: rect, corner-radius: 1em, fill: gradient.radial(red.lighten(80%), red, center: (30%, 20%), radius: 80%)),
  node((0,-1), [Update Four-Potential], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  node((-1,0), [Interpolate E and B \ fields to particles], height: 4em, width: auto, shape: rect, corner-radius: 1em),
  edge((-1,0), (0,1), "-|>", bend: -40deg),
  edge((0,0.8), (1,0), "-|>", bend: -40deg),
  edge((1,0), (0,-1), "-|>", bend: -40deg),
  edge((0,-1), (-1,0), "-|>", bend: -40deg),
)
]
\normalislide(title: "Charge deposition")[
  Recall $ laplace bv(A) = pdv(bv(A),t,2) + bv(J), bv(J) = vec(rho, J_x, J_y, J_z) $
\show math.equation: set text(font: "Libertinus Math", 0.8em)
  Interpolating $rho$, we scatter contributions $Delta rho$
  $ Delta rho_(i + I,j + J, k + K) &= q/(Delta x Delta y Delta z) (1/2 + (-1)^I abs(1/2 - (delta x) / (Delta x)))(1/2 + (-1)^J abs(1/2 - (delta y) / (Delta y)))(1/2 + (-1)^K abs(1/2 - (delta z) / (Delta z))) \ & (I,J,K) in {0,1}^3 $
]
\let p1 = (1.6,1.2)
\let p2 = (2.9,2.5)
\let basecanvas() = {
  import draw: *
  scale(x: 4, y: 4)
  grid((0, 0, 0), (5, 4, 0), stroke: black + .5pt)
  line(p1, p2, stroke: black + 2pt)
  content((p1.at(0), p1.at(1) - 0.1), text(1.5em)[$ vb(r)^(n - 1) $])
  content((p2.at(0), p2.at(1) + 0.1), text(1.5em)[$ vb(r)^n $])
}
\normalislide(title: [ZigZag])[
  \canvas({
    basecanvas()
  })
]
\normalislide(title: [ZigZag])[
  
  
  \canvas({
  import draw: *
  basecanvas()

  let p1xi = int(0.5 * (p1.at(0) + p2.at(0)))
  let p1yi = int(0.5 * (p1.at(1) + p2.at(1)))
  circle((p1xi, p1yi), radius: 2pt, fill: green)
  circle((p1xi+1, p1yi), radius: 2pt, fill: green)
  circle((p1xi, p1yi+1), radius: 2pt, fill: green)
  circle((p1xi+1, p1yi+1), radius: 2pt, fill: green)
  circle((0.5 * (p1.at(0) + p2.at(0)), 0.5 * (p1.at(1) + p2.at(1))), radius: 2pt, fill: red)
  content((0.2 + 0.5 * (p1.at(0) + p2.at(0)), -0.3 + 0.5 * (p1.at(1) + p2.at(1))), text(rgb(200,0,0))[Midpoint])
  //circle((3, 3), radius: 1pt, fill: green)
})
]
\normalislide(title: [ZigZag])[
  \canvas({
  import draw: *
  basecanvas()
  let s1 = (2,1.6)
  let s2 = (2.4,2)
  line(p1, s1, stroke: red     + 3pt)
  line(s1, s2, stroke: green   + 3pt)
  line(s2, p2, stroke: purple  + 3pt)
  let mp(p1, p2, f) = {
    circle((0.5 * (p1.at(0) + p2.at(0)), 0.5 * (p1.at(1) + p2.at(1))), radius: 2pt, fill: f)
  }
  mp(p1, s1, red)
  mp(s1, s2, green)
  mp(s2, p2, purple)
  let deposit(i,j,f) = {
    circle((i, j), radius: 2pt, fill: f)
    circle((i+1, j), radius: 2pt, fill: f)
    circle((i, j+1), radius: 2pt, fill: f)
    circle((i+1, j+1), radius: 2pt, fill: f)
  }
  deposit(1, 1, rgb(255,0,0,100))
  deposit(2, 1, rgb(0,255,0,100))
  deposit(2, 2, rgb(255,0,255,100))
})
]
\normalislide(title: [ZigZag])[
  \canvas({
  import draw: *
  basecanvas()
  let s1 = (2,2)
  line(p1, s1, stroke: red     + 3pt)
  line(s1, p2, stroke: green  + 3pt)
  let mp(p1, p2, f) = {
    //circle(p1.zip(p2).map(((c1, c2)) => 0.5 * (c1 + c2)), radius: 2pt, fill: f)
    circle(p1.zip(p2).map(cs=> cs.sum()/2), radius: 2pt, fill: f)
    //circle((0.5 * (p1.at(0) + p2.at(0)), 0.5 * (p1.at(1) + p2.at(1))), radius: 2pt, fill: f)
  }
  mp(p1, s1, red)
  mp(s1, p2, green)
  let deposit(i,j,f) = {
    circle((i, j), radius: 2pt, fill: f)
    circle((i+1, j), radius: 2pt, fill: f)
    circle((i, j+1), radius: 2pt, fill: f)
    circle((i+1, j+1), radius: 2pt, fill: f)
  }
  content((1.4,2.2), text(rgb(120,120,0,255))[Relay point])
  deposit(1, 1, rgb(255,0,0,100))
  deposit(2, 2, rgb(0,255,0,100))
  
})
]
\normalislide(title: "Current deposition")[
\show math.equation: set text(font: "Libertinus Math", 0.8em)
  We want to interpolate $display((q(vb(r)_(n) -  vb(r)_(n - 1))) /(Delta t))$ \
  Define ${vb(r)_(n-1), vb(r)_n}$ as a _line_.
  \let va(it) = $vb(it)$
  $ va(r)_"relay" &= vec(x_"relay", y_"relay", z_"relay") &= vec(min(min(i_(n-1) Delta x, i_n Delta x) + Delta x, max(max(i_(n-1) Delta x, i_n Delta x), (r_(n - 1, x) + r_(n, x)) / 2)),
min(min(j_(n-1) Delta y, j_n Delta y) + Delta y, max(max(j_(n-1) Delta y, j_n Delta y), (r_(n - 1, y) + r_(n, y)) / 2)),
min(min(k_(n-1) Delta z, k_n Delta z) + Delta z, max(max(k_(n-1) Delta z, k_n Delta z), (r_(n - 1, z) + r_(n, z)) / 2))) $
defines a split of ${vb(r)_(n-1), vb(r)_n}$ into ${vb(r)_(n-1), vb(r)_"relay"} + {vb(r)_"relay", vb(r)_n}$ @ESIRKEPOV2001144 @UMEDA200373 @fallahi2020mithra
\pause
$ Delta upright(J)_(i + I,j + J, k + K) &= (q (vb(r)_(n) - vb(r)_(n - 1)))/(Delta x Delta y Delta z Delta t) (1/2 + (-1)^I abs(1/2 - (delta x) / (Delta x)))(1/2 + (-1)^J abs(1/2 - (delta y) / (Delta y)))(1/2 + (-1)^K abs(1/2 - (delta z) / (Delta z))) $
$upright(J)$ has units $display(upright(A)/(upright(m)^2) = upright(C) upright(m) / upright(s) 1/upright(m^3))$
]

\newsectionslide(title: "The Poynting Vector")[]
\normalislide(title: [Definition])[
  $ bv(S) = 1/mu_0 bv(E) times bv(B) $
  $--> $ Describes flow of energy \ \
  $--> $ Is in unit $display(upright(W)/upright(\h(0.3em)m^2))$
]
\normalislide(title: "Plane wave case")[
  \canvas({
  import draw: *

  // Set up the transformation matrix
  set-transform(matrix.transform-rotate-dir((1, 1, -1.3), (0, 1, .3)))
  scale(x: 2.5, y: 2.5, z: -1.5)

  grid((0,-2), (8,2), stroke: gray + .5pt)
  
  // Draw a sine wave on the xy plane
  let wave(amplitude: 1, fill: none, phases: 2, scale: 8, samples: 100) = {
    line(..(for x in range(0, samples + 1) {
      let x = x / samples
      let p = (2 * phases * calc.pi) * x
      ((x * scale, calc.sin(p) * amplitude),)
    }), fill: fill)

    let subdivs = 8
    for phase in range(0, phases) {
      let x = phase / phases
      for div in range(1, subdivs + 1) {
        let p = 2 * calc.pi * (div / subdivs)
        let y = calc.sin(p) * amplitude
        let x = x * scale + div / subdivs * scale / phases
        line((x, 0), (x, y), stroke: rgb(0, 0, 0, 150) + .5pt)
      }
    }
  }

  group({
    rotate(x: 90deg)
    wave(amplitude: 2, fill: rgb(0, 0, 255, 70))
  })
  content((1, 0, 2.4), text(blue)[E])
  content((1, 1), text(red)[B])
  content((2.5, 0.5), text(rgb(255,255,0))[S])
  wave(amplitude: 0.4, fill: rgb(255, 0, 0, 100))
  set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 2pt + rgb(255,255,0))
  line((1,0,0), (3,0,0))
  set-style(mark: (end: ">", width: 5pt, length: 10pt), stroke: 2pt + red)
  //set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 1pt + rgb(0,130,80))
  line((1,0,0), (1,0.5,0))
  set-style(mark: (end: ">", width: 5pt, length: 10pt), stroke: 1pt + blue)
  line((1,0,0), (1,0,2))
  //set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 1pt + rgb(0,130,80))
  //line((1,0,0), (1,3,0))
})
]
\normalislide(title: "Stationary electron")[
  $ bv(E) &= (q vb(r))/(4 pi epsilon_0 ||vb(r)||^3) \
   bv(B) &= vb(0) \
  ==> 1/mu_0 bv(E) times bv(B) &= 0 $
]
\let linpart = $(q (vb(n) - vb(beta))) / (gamma^2(1 - vb(n) dot vb(beta))^3|bv(r) - bv(r)_s|^2)$
\let accelpart = $(q vb(n) times ((vb(n) - vb(beta)) times accent(vb(beta), dot))) / (c(1 - vb(n) dot vb(beta))^3|bv(r) - bv(r)_s|)$
\normalislide(title: "Inertially moving electron")[
  Liénard - Wiechert Electric Field:
  $ bv(E) = 1/(4 pi epsilon_0)[linpart + accelpart]_(t_r) $
]
\normalislide(title: "Inertially moving electron")[
  Liénard - Wiechert Electric Field:
  $ bv(E) = 1/(4 pi epsilon_0)[linpart + cancel(accelpart)]_(t_r) $
  \pause
  $ bv(B) &= (vb(n) times bv(E))/c = (-q (vb(n) times vb(beta))) / (c gamma^2(1 - vb(n) dot vb(beta))^3|bv(r) - bv(r)_s|^2) \
  bv(S) &= "some constant " dot vb(beta)/(|bv(r) - bv(r)_s|^4) $
  \pause
  \text(1.1em)[*This means no energy is radiated away*]
]
\normalislide(title: "Accelerated electron")[
  Liénard - Wiechert Electric Field:
  $ bv(E) &= 1/(4 pi epsilon_0)[linpart + accelpart]_(t_r) \
    bv(B) &= (vb(n) times bv(E))/c $
]
\normalislide(title: "Accelerated electron")[
  Liénard - Wiechert Electric Field:
  $ bv(E) &= 1/(4 pi epsilon_0)[cancel(linpart) + accelpart]_(t_r) \
    bv(B) &= (vb(n) times bv(E))/c $
  
  $-->$ Integrating over a sphere yields
  $ (q^2) / (6 pi epsilon_0 c) gamma^6 (||accent(vb(beta), dot)||^2 - ||vb(beta) times accent(vb(beta), dot)||^2) $
]
\normalislide(title: "Accelerated electron")[
  Liénard - Wiechert Electric Field:
  $ bv(E) &= 1/(4 pi epsilon_0)[cancel(linpart) + accelpart]_(t_r) \
    bv(B) &= (vb(n) times bv(E))/c $
  
  $-->$ Integrating over a sphere yields
  $ (q^2) / (6 pi epsilon_0 c) gamma^6 (||accent(vb(beta), dot)||^2 - ||vb(beta) times accent(vb(beta), dot)||^2) $
]
\normalislide(title: "Accelerated electron")[
  \grid(columns: (2fr, 1fr), gutter: 5pt, figure(image("spiral.png", width: 100%), supplement: none, caption: [$log_10 bv(S), gamma = 10$]), block(rect(stroke: 2pt, height: 63%, width: 1cm), fill: gradient.linear(..color.map.turbo, angle: -90deg))+place(dy: 0.2em, [-2.3]) + place(dy: -90%, [11.1]))
]
\newsectionslide(title: "Free Electron Laser")[]
\normalislide(title: [Undulator])[
  \canvas({
  import draw: *

  // Set up the transformation matrix
  //set-transform(matrix.transform-rotate-dir((1, 1, -1.3), (0, 1, .3)))
  scale(x: 2.0, y: 2.0, z: -1.5)

  grid((0,-2), (8,2), stroke: gray + .5pt)
  
  // Draw a sine wave on the xy plane
  let wave(amplitude: 1, fill: none, phases: 2, scale: 8, samples: 100, stronk: rgb(0, 0, 0, 150), subdivs: 8) = {
    line(..(for x in range(0, samples + 1) {
      let x = x / samples
      let p = (2 * phases * calc.pi) * x
      ((x * scale, calc.sin(p) * amplitude),)
    }), fill: fill, stroke: stronk)

    //let subdivs = 8
    for phase in range(0, phases) {
      let x = phase / phases
      for div in range(1, subdivs + 1) {
        let p = 2 * calc.pi * (div / subdivs)
        let y = calc.sin(p) * amplitude
        let x = x * scale + div / subdivs * scale / phases
        line((x, 0), (x, y), stroke: stronk + .5pt)
      }
    }
  }

  group({
    rotate(x: 90deg)
    wave(amplitude: 2, fill: rgb(0, 0, 255, 100))
  })
  content((1, 0, 3), text(1.5em,blue)[$B_0$])
  content((6, 1.3, 0), text(1.5em,black)[$ lambda_u \
   overbrace(\hide[\h(8cm)]) $])
  content((1, 1), text(1.2em,rgb(0, 155, 0, 255))[$prop display(K^2/(2 gamma))$])
  content((3, -0.9), text(1.2em,rgb(0, 155, 0, 255))[Reference trajectory])
  //content((2.5, 0.5), text(rgb(255,255,0))[S])
  wave(amplitude: 0.4, fill: rgb(0, 155, 0, 0), stronk: rgb(0, 155, 0, 255), subdivs : 0)
  //set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 2pt + rgb(255,255,0))
  //line((1,0,0), (3,0,0))
  set-style(mark: (end: ">", width: 5pt, length: 7pt), stroke: 2pt + rgb(0, 155, 0, 255))
  //set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 1pt + rgb(0,130,80))
  line((1,0,0), (1,0.5,0))
  
  line((-2,0,0), (0,0,0))
  set-style(mark: (end: ">", width: 5pt, length: 10pt), stroke: 2pt + red)
  line((0,0,0), (1.4,0,0))
  set-style(mark: (end: none, width: 5pt, length: 10pt), stroke: 1pt + black)
  line((-1,-2,0), (0,0,0))
  content((-1,-3,0), text()[Bunch enters with \text(rgb(0,120,0))[$gamma$], \ slowed down to \text(rgb(200,0,0))[$gamma_0 = display(gamma / sqrt(1 + K^2/2))$] ])
  set-style(mark: (end: ">", width: 5pt, length: 10pt), stroke: 2pt + blue)
  line((1,0,0), (1,0,2))
  //set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 1pt + rgb(0,130,80))
  //line((1,0,0), (1,3,0))
})
\place(dx: 60%, dy: -10%)[$ upright(K) = e / (2 pi m_e c) B_0 lambda_u $]
]
\normalislide(title: [Ponderomotive Forces])[
    \canvas({
  import draw: *

  // Set up the transformation matrix
  //set-transform(matrix.transform-rotate-dir((1, 1, -1.3), (0, 1, .3)))
  scale(x: 2.0, y: 2.0, z: -1.5)

  grid((0,-2), (10,2), stroke: gray + .5pt)
  
  // Draw a sine wave on the xy plane
  let wave(amplitude: 1, fill: none, phases: 2, scale: 10, samples: 100, stronk: rgb(0, 0, 0, 150), subdivs: 8) = {
    line(..(for x in range(0, samples + 1) {
      let x = x / samples
      let p = (2 * phases * calc.pi) * x
      ((x * scale, calc.sin(p) * amplitude),)
    }), fill: fill, stroke: stronk)

    //let subdivs = 8
    for phase in range(0, phases) {
      let x = phase / phases
      for div in range(1, subdivs + 1) {
        let p = 2 * calc.pi * (div / subdivs)
        let y = calc.sin(p) * amplitude
        let x = x * scale + div / subdivs * scale / phases
        line((x, 0), (x, y), stroke: stronk + .5pt)
      }
    }
  }
  let dwave(amplitude: 1, fill: none, phases: 2, scale: 10, samples: 100, stronk: rgb(0, 0, 0, 150), subdivs: 8) = {
    line(..(for x in range(0, samples + 1) {
      let x = x / samples
      let p = (2 * phases * calc.pi) * x
      ((x * scale, calc.sin(p) * amplitude / (-0.7*calc.cos(p / 10) + 3 - x * 0.7), calc.cos(p / 10)),)
    }), fill: fill, stroke: stronk)
  }

  group({
    rotate(x: 90deg)
    wave(amplitude: 2, phases:20,samples: 200,subdivs:0, fill: rgb(0, 0, 255, 100))
  })
  dwave(amplitude: 2, phases:20, samples: 500,subdivs:0, fill: rgb(0, 0, 255, 0), stronk: rgb(0,150,0) + 3pt)
})
]
\normalislide(title: "Moving frame")[
  Entire simulation takes place in boosted frame:
  $ gamma_0 = gamma / sqrt(1 + display(upright(K)^2 / 2)), \h(1em) upright(K) = e / (2 pi m_e c) B_0 lambda_u $
]
\normalislide(title: [Lorentz Transforms])[
  \let gb = $gamma beta$
  $ bb(L) = 
    mat( gamma, -gb_x, -gb_y, -gb_x; 
        -gb_x, 1 + ((gamma - 1) beta_x^2) / (||beta||^2), ((gamma - 1) beta_x beta_y) / (||beta||^2), ((gamma - 1) beta_x beta_z) / (||beta||^2);
        -gb_y, ((gamma - 1) beta_x beta_y) / (||beta||^2), 1 + ((gamma - 1) beta_y^2) / (||beta||^2), ((gamma - 1) beta_y beta_z) / (||beta||^2);
        -gb_z, ((gamma - 1) beta_x beta_z) / (||beta||^2), ((gamma - 1) beta_y beta_z) / (||beta||^2), 1 + ((gamma - 1) beta_z^2) / (||beta||^2);
  )
 $
 
]
\normalislide(title: [Lorentz Transform])[
  $ bv(r)^alpha_"bunch" = bb(L)^alpha_beta bv(r)^beta_"lab" $
  \let vv = $vb(upright(v))$
  \let vvb = $vb(upright(v))_"bunch"$
  \let bb = $vb(beta)_"bunch"$
  \let bl = $vb(beta)_"lab"$
  \let vvl = $vb(upright(v))_"lab"$
  
  $ bb = 1/(1 - display((vb(beta) dot bl)))[bl/gamma - vb(beta) +  gamma/(1+gamma) (bl dot vb(beta)) vb(beta)] $
  \pause
  Particles end up with nonzero time $bv(r)^0$ \v(2em)
  $-->$ Correction of $bv(r)^(1..3) := bv(r)^(1..3) - c vb(beta)bv(r)^0$
]

\normalislide(title: "Setup")[
  //\image("outimage00501.png")
  \set block(spacing: 0.7em)

  + Initialize particles \~ gaussian distribution
  + \[Transform positions and velocities to a co-moving frame
  ]
  
  + Apply the PIC Loop
    - After every timestep, sample the forward radiation
  /*\for i in range(3,8){
    text((3em / float(i)))[\i.\hide[.] Apply the PIC Loop \ ]
    set par(leading:1em)
    pause
  }
  \for i in range(8,40){
    text((3em / float(i)))[\i.\hide[.] Apply the PIC Loop \ ]
    set par(leading:1em)
  }*/
]
\normalislide(title: [Boost])[
  \canvas({
  import draw: *

  // Set up the transformation matrix
  let box(x,y,z,s) = {
    line((x,y,z), (x+1,y,z)        , stroke: s)
    line((x,y,z), (x,y+1,z)        , stroke: s)
    line((x,y,z), (x,y,z+1)        , stroke: s)
    line((x+1,y,z), (x+1,y+1,z)    , stroke: s)
    line((x+1,y,z), (x+1,y,z+1)    , stroke: s)
    line((x,y+1,z), (x+1,y+1,z)    , stroke: s)
    line((x,y+1,z), (x,y+1,z+1)    , stroke: s)
    line((x,y,z+1), (x,y+1,z+1)    , stroke: s)
    line((x,y,z+1), (x+1,y,z+1)    , stroke: s)
    line((x+1,y+1,z), (x+1,y+1,z+1), stroke: s)
    line((x+1,y,z+1), (x+1,y+1,z+1), stroke: s)
    line((x,y+1,z+1), (x+1,y+1,z+1), stroke: s)
  }
  set-transform(matrix.transform-rotate-dir((0.2,0.5,-1), (0, 1, 0)))
    scale(x: 1,y:1,z:-1)
    grid((0,-2), (16,3), stroke: gray + .5pt)
    for i in range(0,16){
      box(i,-2,0, if (calc.rem(i,2) == 0){ blue + 2pt} else{red+2pt})
      box(i,2,0, if (calc.rem(i,2) == 0){ blue  + 2pt} else{red+2pt})
    }
    circle((0,1,1), radius: (1,1), stroke: green+3pt)
  })
  becomes
  \canvas({
  import draw: *
  let box(x,y,z,s) = {
    line((x,y,z), (x+1,y,z)        , stroke: s)
    line((x,y,z), (x,y+1,z)        , stroke: s)
    line((x,y,z), (x,y,z+1)        , stroke: s)
    line((x+1,y,z), (x+1,y+1,z)    , stroke: s)
    line((x+1,y,z), (x+1,y,z+1)    , stroke: s)
    line((x,y+1,z), (x+1,y+1,z)    , stroke: s)
    line((x,y+1,z), (x,y+1,z+1)    , stroke: s)
    line((x,y,z+1), (x,y+1,z+1)    , stroke: s)
    line((x,y,z+1), (x+1,y,z+1)    , stroke: s)
    line((x+1,y+1,z), (x+1,y+1,z+1), stroke: s)
    line((x+1,y,z+1), (x+1,y+1,z+1), stroke: s)
    line((x,y+1,z+1), (x+1,y+1,z+1), stroke: s)
  }
  // Set up the transformation matrix
  set-transform(matrix.transform-rotate-dir((0.2,0.5,-1), (0, 1, 0)))
    scale(x: 1,y:1,z:-1)
    grid((0,-2), (16,3), stroke: gray + .5pt)
    scale(x:0.3,y:1,z: 1)
    for i in range(0,60){
      box(i,-2,0, if (calc.rem(i,2) == 0){ blue + 2pt} else{red+2pt})
      box(i,2,0, if (calc.rem(i,2) == 0){ blue  + 2pt} else{red+2pt})
    }
    scale(x:10,y:1,z: 1)
    circle((0,1,1), radius: (1,1), stroke: green+3pt)
  })
]
\normalislide(title: "Forward Radiation")[
  Evaluate $ integral.surf_(z^+ "plane") bv(S)_"lab" dif vb(n)  $ 
  \let vb(it) = $bv(it)$
  \canvas({
  import draw: *

  // Set up the transformation matrix
  set-transform(matrix.transform-rotate-dir((1, 1, -1.3), (0, 1, .3)))
  scale(x: 2.5, y: 1.5, z: -1.5)

  grid((0,-2), (8,2), stroke: gray + .5pt)
  
  // Draw a sine wave on the xy plane
  let wave(amplitude: 1, fill: none, phases: 2, scale: 1, samples: 400, stronk: rgb(0, 0, 0, 150), subdivs: 8, flipped: false) = {
    line(..(for x in range(0, samples + 1) {
      let x = x / samples
      let p = (phases * calc.pi) * x
      if(flipped){
         ((x * 5 + 1, 0, calc.sin(p) * amplitude+1),)
      }else{
         ((x * 5 + 1, calc.sin(p) * amplitude,1),)
      }
    }), fill: fill, stroke: stronk)
  }
  wave(amplitude: 1.3, phases: 10, fill: rgb(0, 0, 255, 100), flipped: true)
  wave(amplitude: 1.3, phases: 10, fill: rgb(255, 0, 0, 100))
  line((1,-1,0), (1,1,0))
  line((1,1,0), (1,1,2))
  line((1,1,2), (1,-1,2))
  line((1,-1,2), (1,-1,0))
  line((6,-1,0), (6, 1,0))
  line((6, 1,0), (6, 1,2))
  line((6, 1,2), (6,-1,2))
  line((6,-1,2), (6,-1,0))
  line((1,-1,2), (6,-1,2))
  set-style(mark: (end: ">", width: 15pt, length: 15pt), stroke: 2pt + rgb(0,255,80))
  line((1,0.0,1), (-1,0.0,1))
  content((-1.2,0.0,1), text(rgb(0,150,80), [$bold(n)$]))
})
]
\normalislide(title: "Electromagnetic Transform")[
  $ vb(E)_"lab" &= gamma(vb(E) - vb(v) times vb(B)      ) &&- (gamma - 1)(vb(E) dot vb(accent(v, hat)))vb(accent(v, hat)) \ 
    vb(B)_"lab" &= gamma(vb(B) + (vb(v) times vb(E))/c^2) &&- (gamma - 1)(vb(B) dot vb(accent(v, hat)))vb(accent(v, hat)) $
]
\normalislide(title: "Boost correction")[
  \box({
    set block(spacing: 0.4em)
    pad(1cm, {
      image("outimage13600_notcorrected.png")
      place(line(start:(0%,0%), end:(100%,0%), stroke: 5pt))
      place(line(start:(0%,0%), end:(-0%,-18%), stroke: 5pt))
      place(dx: -2.8em, dy: -60%, [X [m]])
      place(dx: 50%, dy:0.5em, [Z [m]])
    })
    align(center)[$bv(E) times bv(B)$ evaluated in the bunch frame]
    }
  )
  \box({
    set block(spacing: 0.4em)
    pad(1cm, {
      image("outimage13600.png")
      place(line(start:(0%,0%), end:(100%,0%), stroke: 5pt))
      place(line(start:(0%,0%), end:(0%,-18%), stroke: 5pt))
      place(dx: -2.8em, dy: -60%, [X [m]])
      place(dx: 50%, dy:0.5em, [Z [m]])
    })
    align(center)[$bv(E) times bv(B)$ evaluated in the lab frame]
    }
  )
]
\normalislide(title: [Laboratory frame])[
  Observed wavelength: $ lambda_u (1 - beta_0) $
  \image("undul.png")
  \pause
  $ 1 - beta_0 = 1 - sqrt(1 - 1/gamma_0^2) = 1/(2 gamma_0^2) + 1/(8 gamma_0^4) + ... $
  \pause
  $ lambda_u (1 - beta_0) approx lambda_u/(2 gamma_0^2) $
]
\newsectionslide(title: "Implementation and Results")[]
\let sourceblock(ct) = {
  set raw(theme: "latex.tmTheme")
  show raw.line: it => {
    box(width: 2em, box(width: 1em, align(right,text(font: "New Computer Modern", 
    str(it.number))))) + box(width: 1fr, text(it))
  }
  block(
    fill: luma(220),
    stroke: (y: 0.0pt),
    inset: 8pt,
    radius: 8pt,
    ct
  )
}

\normalislide(title: [Memory Savings])[
\set text(0.8em)
- `anm1view` $= bv(A)^(n-1)$
- `aview` $= bv(A)^n$
\sourceblock()[
  ```cpp
Kokkos::parallel_for(
"Four potential update", ippl::getRangePolicy(aview,nghost),
KOKKOS_LAMBDA(unsigned i, unsigned j, unsigned k) {
      FourVector_t interior = 
      -anm1view(i, j, k) + a1 * aview(i, j, k)
      + a2 * (aview(i + 1, j, k) + aview(i - 1,j, k))
      + a4 * (aview(i, j + 1, k) + aview(i, j - 1, k))
      + a6 * (aview(i, j, k + 1) + aview(i, j, k - 1))
      + a8 * (-source_view(i, j, k));
      anm1view(i, j, k) = interior;
    }
});
swap(aview, anm1view);
  ```
]
\pause
Only possible if boundary conditions don't depend on $bv(A)^(n+1)$
]
\normalislide(title: [Memory Locality])[
\set text(0.7em)
\grid(columns: (1fr,0.3fr, 1fr))[
$ vec(i_"int", j_"int", k_"int") &= vec(floor(r_x / (Delta x)), floor(r_y / (Delta y)), floor(r_z / (Delta z))) $][and][
$ vec(delta x, delta y, delta z) &= vec(r_x / (Delta x) - i_"int", r_y / (Delta y) - j_"int", r_z / (Delta z) - k_"int") $]
  \sourceblock[```cpp
auto [ipos, fracpos] = gridCoordinatesOf(hr, orig, pos);
  ```]
\sourceblock[```cpp
atomicAdd(&rhoview(ipos[0], ipos[1], ipos[2]), ...)
//Is equivalent to
atomicAdd(&rhoview[ipos[0] + ipos[1] * m + ipos[2] * m * n],  ...)
```]
\pause
$-->$ Sort particles by memory index $ i_"int" + m j_"int" + m n k_"int" $
]
\normalislide(title: [Memory Locality])[
  This yields a massive speedup
  \image("scatter.svg", width: 80%)
  Correlated particle motion \ $-->$ sort only every 100th timestep.
]

\normalislide(title: "Final result")[
  More noise since MITHRA filters frequencies.
  \image("mithra_comparison.svg", width: 80%)
]
\normalislide(title: "Scaling")[
  \grid(columns: (0.3fr, 1fr, 1fr),stroke:(y: 1pt), gutter: 0pt,
    [Strong Scaling],
    image("strong_scaling.svg"),
    image("strong_scaling_eff.svg"),
    [Weak Scaling],
    image("weak_scaling.svg"),
  )
]
\normalislide(title: "Bibliography")[
  \set text(0.5em)
  \bibliography("report.bib")
]